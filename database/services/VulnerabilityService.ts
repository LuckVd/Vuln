import { executeQuery, executeTransaction } from '../config/database';
import {
  Vulnerability,
  CreateVulnerabilityInput,
  UpdateVulnerabilityInput
} from '../models/Vulnerability';

export class VulnerabilityService {

  // 获取所有漏洞
  static async getAllVulnerabilities(): Promise<Vulnerability[]> {
    const query = `
      SELECT * FROM vulnerabilities
      ORDER BY discovery_time DESC
    `;
    return await executeQuery(query);
  }

  // 根据条件查询漏洞
  static async getVulnerabilitiesByFilter(filter: {
    page?: number;
    pageSize?: number;
    search?: string;
    riskLevel?: string;
    status?: string;
  }): Promise<{ data: Vulnerability[]; total: number }> {
    let whereConditions = [];
    let params = [];

    // 搜索条件
    if (filter.search) {
      whereConditions.push('(name LIKE ? OR id LIKE ? OR description LIKE ?)');
      params.push(`%${filter.search}%`, `%${filter.search}%`, `%${filter.search}%`);
    }

    // 风险等级过滤
    if (filter.riskLevel) {
      whereConditions.push('risk_level = ?');
      params.push(filter.riskLevel);
    }

    // 状态过滤
    if (filter.status) {
      whereConditions.push('status = ?');
      params.push(filter.status);
    }

    const whereClause = whereConditions.length > 0 ? `WHERE ${whereConditions.join(' AND ')}` : '';

    // 获取总数
    const countQuery = `SELECT COUNT(*) as total FROM vulnerabilities ${whereClause}`;
    const [countResult] = await executeQuery(countQuery, params);
    const total = countResult.total;

    // 获取分页数据
    const page = filter.page || 1;
    const pageSize = filter.pageSize || 10;
    const offset = (page - 1) * pageSize;

    const dataQuery = `
      SELECT * FROM vulnerabilities
      ${whereClause}
      ORDER BY discovery_time DESC
      LIMIT ? OFFSET ?
    `;
    params.push(pageSize, offset);

    const data = await executeQuery(dataQuery, params);

    return { data, total };
  }

  // 根据ID获取漏洞
  static async getVulnerabilityById(id: string): Promise<Vulnerability | null> {
    const query = 'SELECT * FROM vulnerabilities WHERE id = ?';
    const results = await executeQuery(query, [id]);
    return results.length > 0 ? results[0] : null;
  }

  // 根据审批单ID获取漏洞
  static async getVulnerabilitiesByApprovalId(approvalId: string): Promise<Vulnerability[]> {
    const query = `
      SELECT * FROM vulnerabilities
      WHERE approval_id = ?
      ORDER BY risk_level DESC, discovery_time DESC
    `;
    return await executeQuery(query, [approvalId]);
  }

  // 获取未分配的漏洞
  static async getUnassignedVulnerabilities(): Promise<Vulnerability[]> {
    const query = `
      SELECT * FROM vulnerabilities
      WHERE approval_id IS NULL
      ORDER BY discovery_time DESC
    `;
    return await executeQuery(query);
  }

  // 创建漏洞
  static async createVulnerability(input: CreateVulnerabilityInput): Promise<Vulnerability> {
    const id = `VUL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    const query = `
      INSERT INTO vulnerabilities (
        id, name, source, risk_level, discovery_time, expected_block_time,
        status, description, severity, affected_component, recommendation,
        created_by, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const params = [
      id,
      input.name,
      input.source,
      input.riskLevel,
      input.discoveryTime,
      input.expectedBlockTime,
      'pending',
      input.description,
      input.severity,
      input.affectedComponent,
      input.recommendation,
      input.createdBy || 'system',
      now,
      now
    ];

    await executeQuery(query, params);

    // 返回创建的漏洞
    return await this.getVulnerabilityById(id);
  }

  // 更新漏洞
  static async updateVulnerability(id: string, input: UpdateVulnerabilityInput): Promise<boolean> {
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    const updateFields = [];
    const params = [];

    // 动态构建更新字段
    if (input.name !== undefined) {
      updateFields.push('name = ?');
      params.push(input.name);
    }
    if (input.riskLevel !== undefined) {
      updateFields.push('risk_level = ?');
      params.push(input.riskLevel);
    }
    if (input.status !== undefined) {
      updateFields.push('status = ?');
      params.push(input.status);
    }
    if (input.description !== undefined) {
      updateFields.push('description = ?');
      params.push(input.description);
    }
    if (input.severity !== undefined) {
      updateFields.push('severity = ?');
      params.push(input.severity);
    }
    if (input.affectedComponent !== undefined) {
      updateFields.push('affected_component = ?');
      params.push(input.affectedComponent);
    }
    if (input.recommendation !== undefined) {
      updateFields.push('recommendation = ?');
      params.push(input.recommendation);
    }
    if (input.expectedBlockTime !== undefined) {
      updateFields.push('expected_block_time = ?');
      params.push(input.expectedBlockTime);
    }

    updateFields.push('updated_at = ?');
    params.push(now);

    if (updateFields.length === 0) {
      return true; // 没有需要更新的字段
    }

    const query = `
      UPDATE vulnerabilities
      SET ${updateFields.join(', ')}
      WHERE id = ?
    `;

    params.push(id);

    try {
      await executeQuery(query, params);
      return true;
    } catch (error) {
      console.error('更新漏洞失败:', error);
      return false;
    }
  }

  // 将漏洞关联到审批单
  static async assignVulnerabilityToApproval(
    vulnerabilityId: string,
    approvalId: string
  ): Promise<boolean> {
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
    const query = `
      UPDATE vulnerabilities
      SET approval_id = ?, status = 'approved', updated_at = ?
      WHERE id = ?
    `;

    try {
      await executeQuery(query, [approvalId, now, vulnerabilityId]);
      return true;
    } catch (error) {
      console.error('分配漏洞到审批单失败:', error);
      return false;
    }
  }

  // 从审批单中移除漏洞
  static async removeVulnerabilityFromApproval(
    vulnerabilityId: string,
    approvalId: string
  ): Promise<boolean> {
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    // 先验证漏洞是否属于该审批单
    const checkQuery = 'SELECT id FROM vulnerabilities WHERE id = ? AND approval_id = ?';
    const checkResults = await executeQuery(checkQuery, [vulnerabilityId, approvalId]);

    if (checkResults.length === 0) {
      console.error('漏洞不属于该审批单');
      return false;
    }

    const updateQuery = `
      UPDATE vulnerabilities
      SET approval_id = NULL, status = 'unassigned', updated_at = ?
      WHERE id = ? AND approval_id = ?
    `;

    try {
      await executeQuery(updateQuery, [now, vulnerabilityId, approvalId]);
      console.log(`✅ 漏洞 ${vulnerabilityId} 已从审批单 ${approvalId} 中移除，状态更新为未分配`);
      return true;
    } catch (error) {
      console.error('移除漏洞关联失败:', error);
      return false;
    }
  }

  // 批量分配漏洞到审批单
  static async batchAssignVulnerabilitiesToApproval(
    vulnerabilityIds: string[],
    approvalId: string
  ): Promise<{ success: number; failed: number }> {
    const now = new Date().toISOString().slice(0, 19).replace('T', ' ');

    const queries = vulnerabilityIds.map(id => ({
      query: `
        UPDATE vulnerabilities
        SET approval_id = ?, status = 'approved', updated_at = ?
        WHERE id = ?
      `,
      params: [approvalId, now, id]
    }));

    try {
      const results = await executeTransaction(queries);
      if (results.success) {
        console.log(`✅ 成功将 ${vulnerabilityIds.length} 个漏洞分配到审批单 ${approvalId}`);
        return { success: vulnerabilityIds.length, failed: 0 };
      } else {
        console.error('批量分配漏洞失败');
        return { success: 0, failed: vulnerabilityIds.length };
      }
    } catch (error) {
      console.error('批量分配漏洞异常:', error);
      return { success: 0, failed: vulnerabilityIds.length };
    }
  }

  // 删除漏洞
  static async deleteVulnerability(id: string): Promise<boolean> {
    const query = 'DELETE FROM vulnerabilities WHERE id = ?';

    try {
      const result = await executeQuery(query, [id]);
      return result.affectedRows > 0;
    } catch (error) {
      console.error('删除漏洞失败:', error);
      return false;
    }
  }
}